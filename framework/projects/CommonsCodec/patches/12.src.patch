diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java
index 2521c27b..53c3d85a 100644
--- a/src/java/org/apache/commons/codec/binary/Base64.java
+++ b/src/java/org/apache/commons/codec/binary/Base64.java
@@ -406,9 +406,13 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {
     int readResults(byte[] b, int bPos, int bAvail) {
         if (buffer != null) {
             int len = Math.min(avail(), bAvail);
+            if (buffer != b) {
             System.arraycopy(buffer, readPos, b, bPos, len);
             readPos += len;
             if (readPos >= pos) {
+                    buffer = null;
+                }
+            } else {
                 buffer = null;
             }
             return len;
@@ -416,6 +420,14 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {
         return eof ? -1 : 0;
     }
 
+    void setInitialBuffer(byte[] out, int outPos, int outAvail) {
+        if (out != null && out.length == outAvail) {
+            buffer = out;
+            pos = outPos;
+            readPos = outPos;
+        }
+    }
+
     /**
      * <p>
      * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
@@ -468,8 +480,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {
             }
             // Don't want to append the CRLF two times in a row, so make sure previous
             // character is not from CRLF!
-            byte b = lineSeparator[lineSeparator.length - 1];
-            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {
+            if (lineLength > 0 && pos > 0) {
                 System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
                 pos += lineSeparator.length;
             }
@@ -727,6 +738,9 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {
         if (pArray == null || pArray.length == 0) {
             return pArray;
         }
+        long len = (pArray.length * 3) / 4;
+        byte[] buf = new byte[(int) len];
+        setInitialBuffer(buf, 0, buf.length);
         decode(pArray, 0, pArray.length);
         decode(pArray, 0, -1); // Notify decoder of EOF.
         byte[] result = new byte[pos];
@@ -912,10 +926,19 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {
         if (pArray == null || pArray.length == 0) {
             return pArray;
         }
+        long len = getEncodeLength(pArray, lineLength, lineSeparator);
+        byte[] buf = new byte[(int) len];
+        setInitialBuffer(buf, 0, buf.length);
         encode(pArray, 0, pArray.length);
         encode(pArray, 0, -1); // Notify encoder of EOF.
-        byte[] buf = new byte[pos - readPos];
-        readResults(buf, 0, buf.length);
+        if (buffer != buf) {
+            readResults(buf, 0, buf.length);
+        }
+        if (isUrlSafe() && pos < buf.length) {
+            byte[] smallerBuf = new byte[pos];
+            System.arraycopy(buf, 0, smallerBuf, 0, pos);
+            buf = smallerBuf;
+        }
         return buf;
     }
 
diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java
index ad006f2e..a706702f 100644
--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java
+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java
@@ -166,6 +166,9 @@ public class Base64InputStream extends FilterInputStream {
                 if (!base64.hasData()) {
                     byte[] buf = new byte[doEncode ? 4096 : 8192];
                     int c = in.read(buf);
+                    if (c > 0 && b.length == len) {
+                        base64.setInitialBuffer(b, offset, len);
+                    }
                     if (doEncode) {
                         base64.encode(buf, 0, c);
                     } else {
