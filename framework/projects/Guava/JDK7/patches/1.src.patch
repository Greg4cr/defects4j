diff --git a/google/common/reflect/TypeToken.java b/google/common/reflect/TypeToken.java
index 38aa567..1f375be 100644
--- a/google/common/reflect/TypeToken.java
+++ b/google/common/reflect/TypeToken.java
@@ -744,23 +744,21 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
   }
 
   private static boolean isAssignable(Type from, Type to) {
-    if (to instanceof WildcardType) {
-      // if "to" is <? super Foo>, "from" can be:
-      // Foo, SubFoo, <? extends Foo>.
-      // if "to" is <? extends Foo>, nothing assignable.
-      return isAssignableToAny(from, ((WildcardType) to).getLowerBounds());
+    if (to.equals(from)) {
+      return true;
     }
-    // if "from" is wildcard, it's assignable to "to" if any of its "extends"
-    // bounds is assignable to "to".
-    if (from instanceof WildcardType) {
-      // <? super Base> is of no use in checking 'from' being a subtype of 'to'.
-      return isAssignableFromAny(((WildcardType) from).getUpperBounds(), to);
+    if (to instanceof WildcardType) {
+      return isAssignableToWildcardType(from, (WildcardType) to);
     }
     // if "from" is type variable, it's assignable if any of its "extends"
     // bounds is assignable to "to".
     if (from instanceof TypeVariable) {
-      return from.equals(to)
-          || isAssignableFromAny(((TypeVariable<?>) from).getBounds(), to);
+      return isAssignableFromAny(((TypeVariable<?>) from).getBounds(), to);
+    }
+    // if "from" is wildcard, it'a assignable to "to" if any of its "extends"
+    // bounds is assignable to "to".
+    if (from instanceof WildcardType) {
+      return isAssignableFromAny(((WildcardType) from).getUpperBounds(), to);
     }
     if (from instanceof GenericArrayType) {
       return isAssignableFromGenericArrayType((GenericArrayType) from, to);
@@ -787,38 +785,30 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     return false;
   }
 
-  /** Returns true if {@code from} is subtype of every type in {@code toTypes}. */
-  private static boolean isAssignableToAll(Type from, Type[] toTypes) {
-    for (Type to : toTypes) {
-      if (!isAssignable(from, to)) {
-        return false;
-      }
-    }
-    return true;
+  private static boolean isAssignableToClass(Type from, Class<?> to) {
+    return to.isAssignableFrom(getRawType(from));
   }
 
-  /** Returns true if at least one of {@code toTypes} is supertype of {@code from}. */
-  private static boolean isAssignableToAny(Type from, Type[] toTypes) {
-    for (Type to : toTypes) {
-      if (isAssignable(from, to)) {
-        return true;
-      }
-    }
-    return false;
+  private static boolean isAssignableToWildcardType(
+      Type from, WildcardType to) {
+    // if "to" is <? extends Foo>, "from" can be:
+    // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or
+    // <T extends SubFoo>.
+    // if "to" is <? super Foo>, "from" can be:
+    // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.
+    return isAssignable(from, supertypeBound(to)) && isAssignableBySubtypeBound(from, to);
   }
 
-  /** Returns true if all of {@code fromTypes} are subtypes of {@code to}. */
-  private static boolean areAssignableTo(Type[] fromTypes, Type to) {
-    for (Type from : fromTypes) {
-      if (!isAssignable(from, to)) {
-        return false;
-      }
+  private static boolean isAssignableBySubtypeBound(Type from, WildcardType to) {
+    Type toSubtypeBound = subtypeBound(to);
+    if (toSubtypeBound == null) {
+      return true;
     }
-    return true;
-  }
-
-  private static boolean isAssignableToClass(Type from, Class<?> to) {
-    return to.isAssignableFrom(getRawType(from));
+    Type fromSubtypeBound = subtypeBound(from);
+    if (fromSubtypeBound == null) {
+      return false;
+    }
+    return isAssignable(toSubtypeBound, fromSubtypeBound);
   }
 
   private static boolean isAssignableToParameterizedType(Type from, ParameterizedType to) {
@@ -881,17 +871,50 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
       return true;
     }
     if (to instanceof WildcardType) {
-      // if "to" is <? extends Foo>, "from" can be:
-      // Foo, SubFoo, <? extends Foo>, <? extends SubFoo>, <T extends Foo> or
-      // <T extends SubFoo>.
-      // if "to" is <? super Foo>, "from" can be:
-      // Foo, SuperFoo, <? super Foo> or <? super SuperFoo>.
-      return isAssignableToAll(from, ((WildcardType) to).getUpperBounds())
-          && areAssignableTo(((WildcardType) to).getLowerBounds(), from);
+      return isAssignableToWildcardType(from, (WildcardType) to);
     }
     return false;
   }
 
+  private static Type supertypeBound(Type type) {
+    if (type instanceof WildcardType) {
+      return supertypeBound((WildcardType) type);
+    }
+    return type;
+  }
+
+  private static Type supertypeBound(WildcardType type) {
+    Type[] upperBounds = type.getUpperBounds();
+    if (upperBounds.length == 1) {
+      return supertypeBound(upperBounds[0]);
+    } else if (upperBounds.length == 0) {
+      return Object.class;
+    } else {
+      throw new AssertionError(
+          "There should be at most one upper bound for wildcard type: " + type);
+    }
+  }
+
+  @Nullable private static Type subtypeBound(Type type) {
+    if (type instanceof WildcardType) {
+      return subtypeBound((WildcardType) type);
+    } else {
+      return type;
+    }
+  }
+
+  @Nullable private static Type subtypeBound(WildcardType type) {
+    Type[] lowerBounds = type.getLowerBounds();
+    if (lowerBounds.length == 1) {
+      return subtypeBound(lowerBounds[0]);
+    } else if (lowerBounds.length == 0) {
+      return null;
+    } else {
+      throw new AssertionError(
+          "Wildcard should have at most one lower bound: " + type);
+    }
+  }
+
   @VisibleForTesting static Class<?> getRawType(Type type) {
     // For wildcard or type variable, the first bound determines the runtime type.
     return getRawTypes(type).iterator().next();
