diff --git a/guava/src/com/google/common/collect/MinMaxPriorityQueue.java b/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
index a50bf251e..882411aaa 100644
--- a/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
+++ b/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
@@ -419,13 +419,9 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
     }
     E actualLastElement = elementData(size);
     int lastElementAt = heapForIndex(size).swapWithConceptuallyLastElement(actualLastElement);
-    if (lastElementAt == index) {
       // 'actualLastElement' is now at 'lastElementAt', and the element that was at 'lastElementAt'
       // is now at the end of queue. If that's the element we wanted to remove in the first place,
       // don't try to (incorrectly) trickle it. Instead, just delete it and we're done.
-      queue[size] = null;
-      return null;
-    }
     E toTrickle = elementData(size);
     queue[size] = null;
     MoveDesc<E> changes = fillHole(index, toTrickle);
@@ -825,9 +821,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
             forgetMeNot = new ArrayDeque<E>();
             skipMe = new ArrayList<E>(3);
           }
-          if (!containsExact(skipMe, moved.toTrickle)) {
             forgetMeNot.add(moved.toTrickle);
-          }
           skipMe.add(moved.replaced);
         }
         cursor--;
