diff --git a/org/mockito/internal/configuration/DefaultInjectionEngine.java b/org/mockito/internal/configuration/DefaultInjectionEngine.java
index 846fbf7..49127c4 100644
--- a/org/mockito/internal/configuration/DefaultInjectionEngine.java
+++ b/org/mockito/internal/configuration/DefaultInjectionEngine.java
@@ -15,7 +15,6 @@ import org.mockito.internal.util.reflection.FieldInitializer;
 import java.lang.reflect.Field;
 import java.util.Arrays;
 import java.util.Comparator;
-import java.util.HashSet;
 import java.util.Set;
 
 /**
@@ -32,73 +31,46 @@ public class DefaultInjectionEngine {
             Class<?> field2Type = field2.getType();
 
             if(field1Type.isAssignableFrom(field2Type)) {
-                return 1;
+                return -1;
             }
             if(field2Type.isAssignableFrom(field1Type)) {
-                return -1;
+                return 1;
             }
             return 0;
         }
     };
 
-    /**
-     * Inject mocks in injectMocksFields, and initialize them if needed.
-     *
-     * <p>
-     * <u>Algorithm :<br></u>
-     * for each field annotated by @InjectMocks
-     *   <ul>
-     *   <li>copy mocks set
-     *   <li>initialize field annotated by @InjectMocks
-     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type
-     *     <ul>
-     *     <li>find mock candidate by type
-     *     <li>if more than *one* candidate find mock candidate on name
-     *     <li>if one mock candidate then
-     *       <ul>
-     *       <li>set mock by property setter if possible
-     *       <li>else set mock by field injection
-     *       </ul>
-     *     <li>remove mock from mocks copy (mocks are just injected once)
-     *     <li>else don't fail, user will then provide dependencies
-     *     </ul>
-     *   </ul>
-     * </p>
-     *
-     * @param injectMocksFields Fields annotated by @InjectMocks
-     * @param mocks Mocks
-     * @param testClassInstance The test class instance
-     */
-    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {
-        for (Field field : injectMocksFields) {
-            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);
-            Object injectMocksFieldInstance = null;
+    // for each tested
+    // - for each field of tested
+    //   - find mock candidate by type
+    //   - if more than *one* find mock candidate on name
+    //   - if one mock candidate then set mock
+    //   - else don't fail, user will then provide dependencies
+    public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {
+        for (Field field : testClassFields) {
+            Object fieldInstance = null;
             try {
-                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();
+                fieldInstance = new FieldInitializer(testClass, field).initialize();
             } catch (MockitoException e) {
                 new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);
             }
 
             // for each field in the class hierarchy
-            Class<?> fieldClass = injectMocksFieldInstance.getClass();
+            Class<?> fieldClass = fieldInstance.getClass();
             while (fieldClass != Object.class) {
-                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);
+                injectMockCandidate(fieldClass, mocks, fieldInstance);
                 fieldClass = fieldClass.getSuperclass();
             }
         }
     }
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
-            mocks.remove(injected);
-        }
-    }
-
-    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {
         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();
         Arrays.sort(declaredFields, supertypesLast);
-        return declaredFields;
+
+        for(Field field : declaredFields) {
+            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+        }
     }
 
 }
diff --git a/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java b/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java
index 29d2240..673de91 100644
--- a/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java
+++ b/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java
@@ -21,7 +21,7 @@ public class FinalMockCandidateFilter implements MockCandidateFilter {
             final Object matchingMock = mocks.iterator().next();
 
             return new OngoingInjecter() {
-                public Object thenInject() {
+                public boolean thenInject() {
                     try {
                         if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
@@ -29,14 +29,14 @@ public class FinalMockCandidateFilter implements MockCandidateFilter {
                     } catch (Exception e) {
                         throw new MockitoException("Problems injecting dependency in " + field.getName(), e);
                     }
-                    return matchingMock;
+                    return true;
                 }
             };
         }
 
         return new OngoingInjecter() {
-            public Object thenInject() {
-                return null;
+            public boolean thenInject() {
+                return false;
             }
         };
 
diff --git a/org/mockito/internal/configuration/injection/OngoingInjecter.java b/org/mockito/internal/configuration/injection/OngoingInjecter.java
index a26e0eb..cfffe25 100644
--- a/org/mockito/internal/configuration/injection/OngoingInjecter.java
+++ b/org/mockito/internal/configuration/injection/OngoingInjecter.java
@@ -12,8 +12,8 @@ public interface OngoingInjecter {
      * Please check the actual implementation.
      * </p>
      *
-     * @return the mock that was injected, <code>null</code> otherwise.
+     * @return <code>true</code> if injected, <code>false</code> otherwise.
      */
-    Object thenInject();
+    boolean thenInject();
 
 }
